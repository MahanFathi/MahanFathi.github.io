#+AUTHOR:    Mahan Fathi
#+EMAIL:     mahan0fathi@gmail.com

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [american]

# Setup tikz package for both LaTeX and HTML export:
#+LATEX_HEADER: \usepackage{tikz}
#+PROPERTY: header-args:latex+ :packages '(("" "tikz"))
#+PROPERTY: header-args:latex+ :imagemagick (by-backend (latex nil) (t "yes"))
#+PROPERTY: header-args:latex+ :exports results :fit yes

* Intro

* Initilization and Notation

iLQR is firstly initalized with some dynamicaly feasible trajectory -- this could be merely
a roll-out of dynamics with zero control inputs, however, good initialization makes a difference
in the performance of the alogrithm.

#+name: trajectory
#+header: :fit yes :iminoptions -density 200 -resample 80x80
#+header: :file (by-backend (latex "trajectory.tikz") (t "trajectory.png"))
#+begin_src latex :results raw file
\begin{tikzpicture}

\node (n) at (0, 0) {$x_n^*$};
\node (n-1) at (4, 1) {$x_{n-1}^*$};
\node (n-2) at (8, 0) {$x_{n-2}^*$};
\node (dots_-) at (11, 0.5) {};
\node (dots) at (12, 0.5) {.  .  .};
\node (dots_+) at (13, 0.5) {};
\node (2) at (16, 1) {$x_2^*$};
\node (1) at (20, 0) {$x_1^*$};
\node (0) at (24, 1) {$x_0^*$};

\node (un) at (2, 0.5) [anchor=north] {$u_n^*$};
\node (un-1) at (6, 0.5) [anchor=south] {$u_{n-1}^*$};
\node (u2) at (18, 0.5) [anchor=north] {$u_2^*$};
\node (u1) at (22, 0.5) [anchor=south] {$u_1^*$};

\draw[->]
  (n) edge (n-1) (n-1) edge (n-2) (n-2) edge (dots_-)
  (dots_+) edge (2) (2) edge (1) (1) edge (0)
;

\end{tikzpicture}
#+end_src

#+attr_latex: :float nil :width ""
#+results: trajectory
[[file:trajectory.png]]

Here $n$ denotes the the number of steps remaining in the optimization, i.e. the optimization horizon.
So the next state after $x_n^*$ is $x_{n-1}^*$, by taking action $u_n^*$. The first state, $x_N^*$ is always
given by the problem settings. Also note that $(x_n^*, u_n^*)$ trajectory is a valid sequence, in that they
come from direct execution of actions and collection of states, on the model.


* Optimization Objective and Optimization Steps

The ultimate goal is to solve for the following trajectory optimization problem:

\begin{equation}
\min_{u_n ... u_1} \quad J_0(x_0) + \sum_{i=N}^{1} {g(x_i, u_i)} \\
\textrm{s.t.} \quad  x_{i-1} = f(x_i, u_i) \\
\quad  x_{N} = x_{start}
\end{equation}

$J_i^*(x)$ is the optimal cost-to-go for the remaining $i$ steps. The final cost-to-go, i.e. $J_0$ is given by the
problem setting and $J_0(x) = J_0^*(x)$, since there are no actions left to "optimize." The abovementioned optimization
problem can be solved using many tools, including dynamic programming, e.g. value iteration etc, which solve the
following at each step:

#+NAME eqndp
\begin{equation}
\label{eq:dp}
\min_{u_n} \quad J_{n-1}^*(f(x_n, u_n)) + g(x_n, u_n)
\end{equation}

However, solving for an arbitrary optimization problem at each step is computationally costly and unmanagable.
The thing about LQR that makes it so popular is that it makes dynamic programming recursion painless, by applying
the same analytical update at each step. This update is valid for a system with linear transition model and quadratic
step-cost:

\begin{equation*}
x_{i-1} = A x_i + B u_i \\
g(x, u) = x^T Q x + q x + u^T R u + r u
\end{equation*}

Eventually, deploying LQ simplifications in equation (\ref{eq:dp}) yields:

\begin{equation}
\label{eq:lqr_step}
\min_{u_n} \quad    (x_{n-1}^T V_{n-1} x_{n-1} + v_{n-1} x_{n-1}) +
                    (x_n^T Q x_n + q x_n) +
                    (u_n^T R u_n + r u_n) \\
\text{where:} \quad x_{n-1} = A x_n + B u_n
\end{equation}

It is assumed, correctly, that the optimal cost to go maintains an LQ shape throughout the optimization --
we also need to remember to make sure of that. By setting the gradient of $u_n$ to zero we can solve for
the optimal control input:

\begin{equation}
  \nabla_u [...] = 2 (A x + B u)^T V B + v B + 2 u^T R = 0 \\
  \implies \nabla_u^T [...] = 2 B^T V A x + (2 B^T V B + 2 R) u + B^T v^T = 0
\end{equation}

So the control input is feedback-ish function of $x_n$:

\begin{equation}
\label{eq:feedback}
  u_n = (-(2 B^T V_{n-1} B + 2 R)^{-1} 2 B^T V_{n-1} A) x + -(2 B^T V_{n-1} B + 2 R)^{-1} B^T \\
  u_n = K_n x_n + k_n
\end{equation}

By substituting equation (\ref{eq:feedback}) into (\ref{eq:lqr_step}) we can get J_n^*, which is going to be
in an LQ form, with a constant part which is not going to affect out lives in any way:

\begin{equation}
J_n^*(x) = x^T V_n x + v_n x + const\\
V_n = (A + B K_n)^T V_{n-1} (A + B K_n) + Q + K^T R K \\
v_n = 2 k_n^T B^T V_{n-1} (A + B K_n) + v_{n-1} + q + 2 k_n^T R K_n K_n
\end{equation}

One minor thing we have to bear in mind is that, during the algebraic steps of we assume $V = (V + V^T) / 2$
or in other words, $V$ is symmetric.


* Nonlinearities



* Linearization of Dynamics

To be able to work with linear dynamics, the equations of motion, i.e. $x_{n-1}^* = f(x_n^*, u_n^*)$ need to
be approximated by a first-order taylor expansion:

\begin{equation}
  x_{n-1} \approx x_{n-1}^* + A (x_n - x_n^*) + B (u_n - u_n^*)
\end{equation}

Subtracting $x_n^*$ yields:

\begin{equation}
  x_{n-1} - x_n^* \approx (x_{n-1}^* - x_n^*) + A (x_n - x_n^*) + B (u_n - u_n^*)
\end{equation}

By reparametrizing $x$ and $u$ respectively to $x - x_n^*$ and $u - u_n^*$, an affine system is reached:

\begin{equation}
  \zeta_{n-1} \approx (x_{n-1}^* - x_n^*) + A \zeta_n + B \nu_n \\
  \text{where:} \quad \zeta_m = x_m - x_n^*, \nu_m = u_m - u_n^*
\end{equation}

The $(x_{n-1}^* - x_n^*)$ term is merely a constant, e.g. $c$, and the affine system is further simplified into:

\begin{equation*}
  \zeta_{n-1} \approx c + A \zeta_n + B \nu_n \\
\end{equation*}

\begin{equation}
  \implies z_{n-1}
  =
    \begin{bmatrix}
      \zeta_{n-1} \\
      1
    \end{bmatrix}
  =
    \begin{bmatrix}
      A & c \\
      0 & 1
    \end{bmatrix}
    \begin{bmatrix}
      \zeta_n \\
      1
    \end{bmatrix}
  +
    \begin{bmatrix}
      B \\
      0
    \end{bmatrix}
    \nu_n
  =
  A^\prime z_n + B^\prime \nu_n
\end{equation}

For the sake of brevity the following equation is used to represent the linear dynamical eqution for the rest of
this writing:

\begin{equation}
  z_{n-1} = A^\prime z_n + B^\prime \nu_n
\end{equation}


* setup :noexport:

#+name: setup
#+begin_src emacs-lisp :results silent :exports none
  (defmacro by-backend (&rest body)
    `(case (if (boundp 'backend) (org-export-backend-name backend) nil) ,@body))
#+end_src
# for setting up eval: (org-sbe "setup")
